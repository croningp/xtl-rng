import os
import cv2
import sys
import hashlib
import numpy as np
import scipy.special as sp
import matplotlib
import matplotlib.pyplot as plt

TESTLIST = [
        'monobit_test',
        'frequency_within_block_test',
        'runs_test',
        'longest_run_ones_in_a_block_test',
        'binary_matrix_rank_test',
        'dft_test',
        'non_overlapping_template_matching_test',
        'overlapping_template_matching_test',
        'maurers_universal_test',
        'linear_complexity_test',
        'serial_test',
        'approximate_entropy_test',
        'cumulative_sums_test',
        'random_excursion_test',
        'random_excursion_variant_test',
        ] 


def reset_data():
    
    data = {}
    for testname in TESTLIST:
        data[testname] = {}       
        data[testname]['hist'] = [0 for i in range(10)]
        data[testname]['hist axis'] = np.linspace(0.05, 0.95, 10)
        data[testname]['uniformity'] = 0
        data[testname]['pass rate'] = 0
        data[testname]['pass window'] = 99, 99 
        data[testname]['ps'] = []
    return data

def get_chunks(bitlist, number_of_chunks=None, chunk_length=None):
    # partitions long bitstring into several small chunks of set length
    # returns list of list of integers
    
    # returns original string (in a list) if no parameters are set
    if not number_of_chunks and not chunk_length:
        number_of_chunks, chunk_length = 1, len(bits)
        
    # calculates chunk_length if only number_of_chunks set
    elif number_of_chunks and not chunk_length:
        chunk_length = int(len(bitlist) / number_of_chunks)
    
    # calculates number_of_chunks if only chunk_length set
    elif not number_of_chunks and chunk_length:
        number_of_chunks = int(len(bitlist) / chunk_length)
    
    # generates specified number of chunks with specified length
    chunks = [bitlist[idx*chunk_length:(idx+1)*chunk_length] for idx in range(number_of_chunks)]
    return chunks

def run_chunks(chunks):
    # assess each chunk in a loop
    # results are a dictionary with dict[testname] = [p-values] for all testnames
    chunk_results = list()

    print('Number of chunks: {}, size of chunks: {}'.format(len(chunks), len(chunks[0])))
    len_chunks = len(chunks)
    for idx, chunk in enumerate(chunks):
        sys.stdout.write('\rChunk {} / {}'.format(idx+1, len(chunks)))
        chunk_results.append(run_testlist(idx, len_chunks, chunk))
    return chunk_results

def calc_uniformity(hist):
    chi_sq = sum([(i-(sum(hist)/10))**2/(sum(hist)/10) for i in hist])
    p_value = 1-sp.gammainc(9/2, chi_sq/2)
    return p_value

def calc_passwindow(p_values):

    p_hat = 0.99
    pass_window = 3*np.sqrt((p_hat*(1-p_hat)/len(p_values)))
    pass_min = p_hat - pass_window
    pass_max = p_hat + pass_window
    return pass_min, pass_max

def run_test(testname, chunk):
    m = __import__ ("sp800_22_"+testname)
    func = getattr(m,testname) 
    try:
        (success,p,plist) = func(chunk)
    except Exception as e:
        print(testname, ': ', e)
        (success,p,plist) = (False, 0, None)
        
    return  p

def run_test_on_chunks(testname, chunks):
    ps =  [run_test(testname, chunk) for chunk in chunks]  

    hist = np.histogram(ps, np.linspace(0,1,11))[0]
    
    stats = {'hist': hist,
             'hist axis': np.linspace(0.05, 0.95, 10),
             'uniformity': calc_uniformity(hist),
             'pass rate': sum([1 for p in ps if p > 0.01])/len(ps),
             'pass window': calc_passwindow(ps), 
             'ps': ps
            }

    return stats


import numpy as np
import matplotlib.pyplot as plt

def plot_histograms(stats, colour='mediumseagreen'):
    tests = [i for i in stats if len(stats[i]['ps']) > 0]
    fig, axs = plt.subplots(len(tests), sharex='col', figsize=(6.3,9))

    
    # print(number_of_tests)
    # t2 = 'Substring length: {} sample size: {}\n\n'.format(stats['chunk size'], stats['chunks'])
    # t3 = 'Histograms of p-values generated by statistical tests of the NIST\n'
    # t4 = 'package for a binary string generated by crystallization of '
    # title = t2+t3+t4
    # fig.suptitle(title)

    for idx, test in enumerate(tests):

        axs[idx].bar(stats[test]['hist axis'], stats[test]['hist'], width=0.1, edgecolor='k', color=colour )
        ymax = int(max(stats[test]['hist']) *1.5)
        axs[idx].set_ylim(ymin=0, ymax = ymax)
        text_height = (ymax*0.8+max(stats[test]['hist']))/2
        if test == 'NonOverlappingTemplateMatching':
            fontsize = 6
        else:
            fontsize = 10
        axs[idx].text(0,text_height, test, fontsize=fontsize)
        axs[idx].text(0.45,text_height,'{}'.format(r'$p_{uniform}$'+'    ={0:.4f}'.format(stats[test]['uniformity'])))
        axs[idx].text(0.75, text_height,'pass rate= {0:.4f}'.format(stats[test]['pass rate']))
        axs[idx].minorticks_on()

        if idx == int(len(stats)/2) -1:
            axs[idx].set_ylabel('count', rotation=90)
    axs[idx].set_xlabel('p-value range')
    plt.subplots_adjust(wspace=0, hspace=0)
    return axs

    
def plot_pass_rates(stats, colour='mediumseagreen'):
    fig, ax = plt.subplots()
    xs = []
    ys = []
    tests = [i for i in stats if len(stats[i]['ps']) > 0]
    for test in tests:
        xs.append(test)
        ys.append(stats[test]['pass rate'])
    
    # t1 = 'Pass rates for statistical tests of the NIST package\n'
    # t2 = 'for a binary string generated by crystallization of '
    # fig.suptitle(t1+t2)
    plt.bar(xs, ys,width=0.8,edgecolor='k', color=colour)

    plt.hlines([1], [-1],[len(tests)],  linestyle='-.')
    plt.hlines([stats[test]['pass window'][0]], [-1],[len(tests)],  linestyle='-')
    plt.hlines([0.99], [-1],[len(tests)],  linestyle='--')
    plt.hlines([stats[test]['pass window'][0]], [-1],[len(tests)],  linestyle='-')
    plt.tick_params(axis='x', labelrotation=30, labelleft=True)
    # ax.axis['bottom'].label.set_text('right')
    plt.xticks(rotation=30, ha='right')
    plt.xlim(-1,len(tests))
    y_max = (stats[test]['pass window'][1] + 0.99) / 2
    y_min = (stats[test]['pass window'][0]+0.99)-1
    plt.ylim(y_min, y_max)
    plt.ylabel('Pass rate')
    return ax

def plot_uniformities(stats, colour='mediumseagreen'):
    fig, ax = plt.subplots()
    xs = []
    ys = []
    tests = [i for i in stats if len(stats[i]['ps']) > 0]
    for test in tests:
        xs.append(test)
        ys.append(stats[test]['uniformity'])

    # t1 = 'Uniformity of p-values for histograms of tests of the NIST\n'
    # t2 = 'package for a binary string generated by crystallization of '

    # ax.suptitle(t1+t2)
    plt.bar(xs, ys, width=0.8, edgecolor='k', color=colour)
    plt.xticks(rotation=30, ha='right')
    plt.xlim(-1,len(tests))
    plt.ylabel('Uniformity p-value')
    return ax

def ApEn(U, m):

    def _maxdist(x_i, x_j):
        return   max([abs(ua - va) for ua, va in zip(x_i, x_j)])

    def _phi(m):
        
        blocks = [U[j:j+m] for j in range(N-m+1)]           
        C = [len([1 for b2 in blocks if _maxdist(b1, b2) < 1]) / (N - m + 1.0) for b1 in blocks]
        return (N - m + 1.0)**(-1) * sum(np.log(C))
   
    N = len(U)
    if m > 0: 
        return abs(_phi(m+1) - _phi(m))
    else:
        return abs(-_phi(m+1))

def get_phi(bits, m, n):
    if m == 0:
        return 0 
    padded_bits = bits+bits[0:m-1]      #  augment the sequence with the m-1 initial bits
    counts = [0 for i in range(2**m)]
    for bdx in range(n):
        block = padded_bits[bdx:bdx+m]
        block_as_int = int(''.join([str(i) for i in block]), 2)
        counts[block_as_int] += 1
    Ci = [i/n for i in counts]
    phi_m = 0
    for i in Ci:
        if i > 0: phi_m += i*np.log(i)
    return phi_m
        
def approximate_entropy_test(bits, m):
    n = len(bits)
    phi_m = [get_phi(bits, m, n) for m in range(m, m+2)]

    ApEn = phi_m[0] - phi_m[1]
    return ApEn